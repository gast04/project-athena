# Whats assembly, why does it exist?
I like to be technical so let's directly start with some code, everybody knows
the classic hello world coding example from the C world:

```C
#include <stdio.h>

int main() {
    printf("Hello World\n");
    return 0;
}
```

We can compile it using a standard compiler (I prefer clang here, even it's
always behind the latest features but I like the llvm support).
`clang++-15 1_hello_world.cpp`. And boom, we get a `a.out` which we can execute.

```
>> ./a.out
Hello World
```

Nothing new so far. But what actually happens under hood here? and this is where
assembly joins the party. Also what does the compiler do in order to create and
executeable file? And what does it mean to be executeable?

In short, we will dig into the details later, the compiler converts the text file
to assemlby code, depending on your architecture it will be likely `x86_64`
assembly, or if you work on an arm based Mac it will be `aarch64`.
`x86_64` and `aarch64` are different types of assembly code, with its own
pro and cons. There exist a few dozen of different types,
x86, x86_64, armv7, armv8, aarch64, mips, risc-v, avr, ... the list is long.

Let's have a look at the assembly code the hello world program produces:
(translated by godbolt.org)
```ASM
.LC0:
        .string "Hello World"
main:
        push    rbp
        mov     rbp, rsp
        mov     edi, OFFSET FLAT:.LC0
        call    puts
        mov     eax, 0
        pop     rbp
        ret
```
So what's this now?
It's x86_64 assembly code in the intel asm syntax. This is the code which can be
executed by the CPU. To be fair there is more to it, this is just the main
function. To be fully executeable the binary file also needs a header, dynamic
libraries, maybe symbols, ... But this is the actual code.

The beauty of assembly is that it has a one to one translation to bytes, and
these bytes are then translated by the CPU and later executed.

Let's look at the bytes:
(Generated by IDA-Pro7)
```
.text:01140                   ; int __cdecl main(int argc, const char **argv, const char **envp)
.text:01140                                   public main
.text:01140                   main            proc near
.text:01140                   var_4           = dword ptr -4
.text:01140
.text:01140 55                                      push    rbp
.text:01141 48 89 E5                                mov     rbp, rsp
.text:01144 48 83 EC 10                             sub     rsp, 10h
.text:01148 C7 45 FC 00 00 00 00                    mov     [rbp+var_4], 0
.text:0114F 48 8D 3D AE 0E 00 00                    lea     rdi, format     ; "Hello World\n"
.text:01156 B0 00                                   mov     al, 0
.text:01158 E8 D3 FE FF FF                          call    _printf
.text:0115D 31 C0                                   xor     eax, eax
.text:0115F 48 83 C4 10                             add     rsp, 10h
.text:01163 5D                                      pop     rbp
.text:01164 C3                                      retn
```

To wrap up the full (simplified) execution pipeline the instruction pointer
points to the first instruction `push rbp (55)` the decoder know how much to
decode, 1 byte, and the CPU know what to do with `55`. And then it continues
with the next instruction.

Please note that this is a huge simplification of the execution process of a CPU,
if you are interested in that please try out the internet or ask me after the
lecture.

Let's get back to assembly.


# Assembly (x86_64)
For simplicity we stick to x86_64 as it is the most common one, depending in
which area you work for.

In assembly there are no variables as you know from classical coding, instead
we have registers, those are fixed places to store values in. On the x64
architecture exist 16 general purpose registers 
`RAX, RBX, RCX, RDX, RBP, RSI, RDI, RSP, R8-15` on the x64 architecture these
are 64bit registers. We can fill them with the mov instruction

```ASM
mov rax, 42     ; move immediate 42 into register RAX
mov rbx, [rdi]  ; move value from address RDI into RAX
mov rax, rbx    ; move value from RBX ro RAX
```
Other ways using `movsx, movzx` 


Once Registers have been filled with values we wanna operate on them, classic
operational instructions exists.

```ASM
inc rax
dex rax
add rax, rbx
sub rbx, rcx

and rdx, rcx
or  rax, rbx
xor rax, rax
not rcx        ; Bitwise NOT of RCX, result in RCX

shl rax, 3     ; Shift the bits in RAX left by 3 positions, zero-fill
shr rbx, 1     ; Logical shift the bits in RBX right by 1 position, zero-fill
rol rdx, 4     ; Rotate the bits in RDX left by 4 positions
ror rax, 5     ; Rotate the bits in RAX right by 5 positions

imul rax, rcx  ; Signed multiply RAX by RCX, result in RAX
idiv rbx       ; Signed divide RDX:RAX by RBX, quotient in RAX, remainder in RDX
```

Now registers can be filled and we can operate on them, before our first
example we still need branching and looping.

```ASM
cmp rax, rbx
je equal_target
jne not_equal_traget
jg greater_target       ; Jump to label if RAX is greater than RBX
jle less_target         ; Jump to label if RAX is less than or equal to RBX

jnz not_zero_target     ; Jump to label if ZF (zero flag) is not set

jmp unconditional_target
```

## First example
Create an assembly program which executes a loop exactly 5 times.

```ASM
mov rax, 0
mov rbx, 5

loop_start:
    inc rax         ; Increment the counter in RAX
    cmp rax, rbx    ; Compare the counter with loop count
    jl loop_start   ; Jump to loop_start if RAX < loop_count

; program end
```


# TO BE DONE
Stack pointer
Syscalls
instruction aliases

# Manually coding in assembly?

# Resources
* https://www.intel.com/content/dam/develop/external/us/en/documents/introduction-to-x64-assembly-181178.pdf

